Of course 👍 — here’s the entire ARCHITECTURE_DESIGN.md file in one copy-ready snippet:


---

# 🤖 AI Onboarding & Workplace Assistant — Architecture & Design

**Phases**
- **Phase 1 (Now):** Chatbot with Bedrock + Knowledge Base (read-only Q&A)
- **Phase 2 (Later):** Agent mode (tool actions via Lambdas) + *optional* MCP bridge

**Channels:** Google Chat (1:1 DMs)  
**Core:** Amazon Bedrock (Claude/Titan), Bedrock KB (S3 + optional OpenSearch), AWS Lambda, API Gateway, DynamoDB, CloudWatch, Secrets Manager

---

## 1) End-to-End System (Unified)

```mermaid
flowchart LR
  subgraph Google[Google Workspace]
    U[Employee (Google Chat DM)]
    BOT[Google Chat App (Webhook)]
  end

  subgraph Edge[AWS Edge / Public]
    APIGW[Amazon API Gateway]\nHTTPS (signed)
  end

  %% App VPC (stateless chat layer)
  subgraph APPVPC[AWS VPC - App Layer]
    L_CHAT[Lambda: chat-webhook\n(context enrich, routing)]
    DDB[(DynamoDB\nusers/threads/logs)]
    CW[CloudWatch Logs/Metrics]
    SM[Secrets Manager]
  end

  %% Knowledge VPC (DocOps KB pipeline)
  subgraph KBVPC[AWS VPC - Knowledge/Index]
    GIT[GitHub: DocOps repos]
    S3[S3: DocOps & Policy Content\n(mirrored from GitHub)]
    OS[Amazon OpenSearch Service\n(Vector Store, optional)]
    EMB[Embedding Model\n(Bedrock / OS plugin)]
    KB[Bedrock Knowledge Base\n(Data Source: S3; optional OS)]
    SYNC[Lambda: kb_sync\n(triggered by CloudWatch)]
    CWKB[CloudWatch (KB jobs)]
  end

  %% Phase 2 Actions
  subgraph ACTIONS[AWS VPC - Actions (Phase 2)]
    AG[Bedrock Agent - Action Group]
    L_SUBMIT[Lambda: access-submit]
    L_STATUS[Lambda: access-status]
    L_LIST[Lambda: access-list]
    EXT[(Enterprise APIs: SailPoint/Okta/HRMS/Jira)]
    MCP?[[Optional MCP Bridge\n(client to MCP server)]]
  end

  %% Flow
  U -->|DM| BOT -->|signed webhook| APIGW --> L_CHAT
  L_CHAT -->|Converse| BR[(Amazon Bedrock\n(Claude/Titan) + Guardrails)]
  BR <-->|RAG retrieval| KB
  KB --> S3
  S3 --> OS
  OS --> EMB
  GIT -->|CI sync| S3

  %% KB sync path
  SYNC -->|start_ingestion_job| KB
  CWKB --> SYNC

  %% Observability & state
  L_CHAT --> DDB
  L_CHAT --> CW
  SM --> L_CHAT
  SM --> L_SUBMIT & L_STATUS & L_LIST

  %% Response
  L_CHAT -->|reply| APIGW --> BOT --> U

  %% Phase 2 action calls
  BR -->|tool call| AG
  AG --> L_SUBMIT & L_STATUS & L_LIST
  L_SUBMIT -->|REST/OAuth| EXT
  L_STATUS -->|REST/OAuth| EXT
  L_LIST   -->|REST/OAuth| EXT
  %% optional MCP path (if adopted later)
  AG --> MCP?
  MCP? --> EXT


---

2) Knowledge Base (DocOps) Design

Sources

GitHub docs/, runbooks, SOPs, PDFs → mirrored to S3 (versioned)


Indexing

Option A (simple): Bedrock KB directly over S3

Option B (advanced): OpenSearch vector store; embeddings created by EMB; Bedrock KB queries OS


Sync

kb_sync Lambda (CloudWatch cron or GitHub Actions webhook) → StartIngestionJob (Bedrock KB)

Metadata tags: {department, region, version, sensitivity, owner}


Governance

Human review before sync for sensitive docs

S3 object versioning; rollback by prefix



---

3) Chatbot Application (Phase 1)

Path

1. Google Chat DM → signed webhook → API Gateway


2. chat-webhook Lambda:

Verify signature, map googleUserId → employeeId

Fetch minimal profile (role, region) from DynamoDB

Build safe prompt (PII-minimized), call Bedrock Converse

Return markdown / card reply; log to DDB + CloudWatch




Model

Claude 3.5 Sonnet (primary) and/or Titan Text as fallback

Guardrails enabled (PII filter, deny lists, jailbreak protection)


Performance

p95 ≤ 2s (use provisioned concurrency for chat-webhook)



---

4) Agent Mode & Actions (Phase 2)

Action surface (example)

submit_access_request(app, role?, justification?)

get_access_status(requestId)

list_my_access()


Invocation

Bedrock Agent → Action Group → API Gateway/Lambda

Lambdas perform: input validation (JSON schema), RBAC/ABAC checks, idempotency, call Enterprise APIs (SailPoint/Okta/etc.)


Optional MCP

If you later adopt MCP, add a thin MCP client alongside Lambdas or as a sidecar.

Tool routing: Agent → Action Group → Lambda/Router → (MCP client → MCP server) → target system.


Safety

Human confirmation for high-risk actions

Feature flags / kill-switch per tool

Immutable audit (request, response, actor, correlationId)



---

5) Sequence Flows

5.1 Q&A (Phase 1)

sequenceDiagram
  participant User as Employee
  participant Bot as Google Chat Bot
  participant GW as API Gateway
  participant L as Lambda: chat-webhook
  participant BR as Bedrock (KB)
  participant KB as Bedrock KB/S3/OS
  participant D as DynamoDB

  User->>Bot: "What do I need on Day 1?"
  Bot->>GW: Signed webhook
  GW->>L: Invoke with user identity + text
  L->>D: Fetch minimal context (role/region)
  L->>BR: Converse(prompt + context)
  BR->>KB: Retrieve chunks (RAG)
  KB-->>BR: Grounded content
  BR-->>L: Answer + citations
  L->>Bot: Markdown/card reply
  L->>D: Log (intent, sources, latency)

5.2 Action (Phase 2)

sequenceDiagram
  participant User as Employee
  participant Bot as Google Chat Bot
  participant L as Lambda: chat-webhook
  participant BR as Bedrock Agent
  participant AG as Action Group
  participant A as Lambda: access-submit
  participant EXT as Enterprise APIs

  User->>Bot: "Request VPN access"
  Bot->>L: Forward message
  L->>BR: Agent prompt (policy & context)
  BR->>AG: Tool call: submit_access_request
  AG->>A: Invoke with validated args
  A->>EXT: Create request (OAuth/RBAC)
  EXT-->>A: {requestId:PENDING}
  A-->>AG: Result
  AG-->>BR: Tool result
  BR-->>L: Natural-language summary
  L-->>Bot: "Raised request ✅ (ID: ...)"


---

6) Security & Trust Boundaries (recap)

Boundary A (Google): Users + Chat app (signed webhooks)

Boundary B (Edge): TLS 1.2+ to API Gateway

Boundary C (AWS Private): Lambdas, Bedrock, DDB, S3, OS, Guardrails, KMS everywhere

Boundary D (External APIs – Phase 2): Allow-listed endpoints (SailPoint/Okta/HRMS), OAuth, scopes


Core controls

PII minimization to model

RBAC/ABAC at server for all actions

Idempotency keys on mutating calls

Secrets in AWS Secrets Manager (KMS), never in logs

CloudWatch + SIEM streaming; anomaly alerts

Kill-switch flags for each tool



---

7) Deployment & Environments

Envs: dev → stage → prod
IaC: Terraform (separate workspaces), per-env KMS keys, per-env buckets/tables
CI/CD: GitHub Actions:

Build → unit tests → terraform plan → manual approve → apply

Docs sync: GitHub → S3 → start-ingestion-job (KB)



---

8) Decisions & Extensibility (ADR-style)

Use Bedrock KB over S3 (simple default). OpenSearch vector store stays optional for advanced ranking.

Single chat Lambda now; add action Lambdas later (one per verb or a router).

MCP is optional: introduce only if multiple models/clients must share standardized tools.

Models: start with Claude 3.5 Sonnet; keep Titan Text as fallback policy-friendly option.



---

9) Observability & KPIs

Metrics: p95 latency, error rate, grounding (% answers with source), guardrail blocks, token spend

Targets (Phase 1): p95 ≤ 2s, grounding ≥ 90%, unsafe ≤ 0.5%, CSAT ≥ 4.5/5

Dashboards: CloudWatch (per Lambda + Bedrock), cost dashboard (token & KB jobs)



---

10) Next Steps

1. Finalize KB sources & tags (owners, sensitivity)


2. Stand up dev environment + CI/CD


3. Implement chat-webhook Lambda with Guardrails and logging


4. Run evaluation suite (accuracy, safety)


5. Prepare Phase 2 action contracts (OpenAPI + JSON Schemas) and RBAC matrix




---

---

Would you like me to also prepare the **Phase 2 OpenAPI + JSON Schemas** (for actions like `submit_access_request`, `get_access_status`, `list_my_access`) so you can directly plug them into Bedrock Action Groups?

